<!doctype html>
<html lang="en">
	<head>
	    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" />
	    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
	    <title>Comment on &quot;Overcoming catastrophic forgetting in NNs&quot;: Are multiple penalties needed?</title>
	    <meta name="description" content="" />
	    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,700italic,300,700' rel='stylesheet' type='text/css'>
		<link href='http://fonts.googleapis.com/css?family=Bree+Serif' rel='stylesheet' type='text/css'>
		<link rel="stylesheet" type="text/css" href="/assets/styles/crisp.css?v=a4a8b7e06d">
		<link rel="shortcut icon" href="/content/images/2014/Mar/face.png"/>
	    <meta name="HandheldFriendly" content="True" />
	    <meta name="MobileOptimized" content="320" />
	    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
		<!--[if lt IE 9]>
			<script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
			<script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
		<![endif]-->
	    <link rel="canonical" href="http://www.inference.vc/comment-on-overcoming-catastrophic-forgetting-in-nns-are-multiple-penalties-needed-2/" />
    <meta name="referrer" content="no-referrer-when-downgrade" />
    <link rel="amphtml" href="http://www.inference.vc/comment-on-overcoming-catastrophic-forgetting-in-nns-are-multiple-penalties-needed-2/amp/" />
    
    <meta property="og:site_name" content="inFERENCe" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content="Comment on &quot;Overcoming catastrophic forgetting in NNs&quot;: Are multiple penalties needed?" />
    <meta property="og:description" content="This comment on the DeepMind folks&#x27; latest PNAS paper on overcoming catastrophic forgetting. I liked this paper a lot, I recommend it. Despite this, the post eventually turned into a critical review of the method, rather than the glowing, enthusiastic review I sat down to write. Please don&#x27;t let this" />
    <meta property="og:url" content="http://www.inference.vc/comment-on-overcoming-catastrophic-forgetting-in-nns-are-multiple-penalties-needed-2/" />
    <meta property="og:image" content="http://www.inference.vc/content/images/2017/03/1ljk1i.jpg" />
    <meta property="article:published_time" content="2017-03-16T14:19:11.000Z" />
    <meta property="article:modified_time" content="2017-03-16T20:50:53.000Z" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Comment on &quot;Overcoming catastrophic forgetting in NNs&quot;: Are multiple penalties needed?" />
    <meta name="twitter:description" content="This comment on the DeepMind folks&#x27; latest PNAS paper on overcoming catastrophic forgetting. I liked this paper a lot, I recommend it. Despite this, the post eventually turned into a critical review of the method, rather than the glowing, enthusiastic review I sat down to write. Please don&#x27;t let this" />
    <meta name="twitter:url" content="http://www.inference.vc/comment-on-overcoming-catastrophic-forgetting-in-nns-are-multiple-penalties-needed-2/" />
    <meta name="twitter:image" content="http://www.inference.vc/content/images/2017/03/1ljk1i.jpg" />
    <meta name="twitter:label1" content="Written by" />
    <meta name="twitter:data1" content="Ferenc Huszar" />
    <meta name="twitter:site" content="@fhuszar" />
    <meta property="og:image:width" content="888" />
    <meta property="og:image:height" content="499" />
    
    <script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "publisher": {
        "@type": "Organization",
        "name": "inFERENCe",
        "logo": "http://www.inference.vc/content/images/2014/Mar/face.png"
    },
    "author": {
        "@type": "Person",
        "name": "Ferenc Huszar",
        "image": "//www.gravatar.com/avatar/943e71b49d8fa0b3725fa6c82c97163d?d=404",
        "url": "http://www.inference.vc/author/ferenc-huszar/",
        "sameAs": []
    },
    "headline": "Comment on &quot;Overcoming catastrophic forgetting in NNs&quot;: Are multiple penalties needed?",
    "url": "http://www.inference.vc/comment-on-overcoming-catastrophic-forgetting-in-nns-are-multiple-penalties-needed-2/",
    "datePublished": "2017-03-16T14:19:11.000Z",
    "dateModified": "2017-03-16T20:50:53.000Z",
    "image": {
        "@type": "ImageObject",
        "url": "http://www.inference.vc/content/images/2017/03/1ljk1i.jpg",
        "width": 888,
        "height": 499
    },
    "description": "This comment on the DeepMind folks&#x27; latest PNAS paper on overcoming catastrophic forgetting. I liked this paper a lot, I recommend it. Despite this, the post eventually turned into a critical review of the method, rather than the glowing, enthusiastic review I sat down to write. Please don&#x27;t let this",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "http://www.inference.vc"
    }
}
    </script>

    <meta name="generator" content="Ghost 0.11" />
    <link rel="alternate" type="application/rss+xml" title="inFERENCe" href="http://www.inference.vc/rss/" />
    <script src="//load.sumome.com/" data-sumo-site-id="a378ae33aa68caa37662d339c31c409600c8a85e240c12fceaeb0c70684208c0" async="async"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-96562474-1', 'auto');
  ga('send', 'pageview');

</script>
		<script>
			!function(g,s,q,r,d){r=g[r]=g[r]||function(){(r.q=r.q||[]).push(
			arguments)};d=s.createElement(q);q=s.getElementsByTagName(q)[0];
			d.src='//d1l6p2sc9645hc.cloudfront.net/tracker.js';q.parentNode.
			insertBefore(d,q)}(window,document,'script','_gs');

			_gs('GSN-053712-R');
		</script>
	</head>
	<body class="post-template">
		<header id="header">
			<a id="logo" href="http://www.inference.vc"><img src="/content/images/2014/Mar/face.png" alt="inFERENCe" /></a>
			<h1><a href="http://www.inference.vc">inFERENCe</a></h1>
			<p>posts on machine learning, statistics, opinions on things I&#x27;m reading in the space</p>
			<h6><a href="http://www.inference.vc/about">About</a></h6>
		</header>
		<main id="content">
			<article id="103" class="post">
    <span class="post-stamp">March 16th, 2017</span>
    <h1 class="post-title">Comment on &quot;Overcoming catastrophic forgetting in NNs&quot;: Are multiple penalties needed?</h1>
    <p>This comment on the DeepMind folks' latest PNAS paper on overcoming catastrophic forgetting. I liked this paper a lot, I recommend it. Despite this, the post eventually turned into a critical review of the method, rather than the glowing, enthusiastic review I sat down to write. Please don't let this prevent you from reading the paper:</p>

<ul>
<li>James Kirkpatrick et al (2017) <a href="http://www.pnas.org/content/early/2017/03/13/1611835114.abstract">Overcoming catastrophic forgetting in neural networks</a>, PNAS</li>
</ul>

<p>First, it's a nice paper: simple, clean, statistically motivated solution (see more on this later) and you can clearly see where this is going and how it's relevant to DeepMind's pursuit of general learning machines. üëè. Second, it's a great achievement of the authors and the community that we now regularly see purely machine learning papers solving a machine learning problems in general journals like PNAS, Science and Nature.</p>

<h4 id="summaryofthispost">Summary of this post</h4>

<ul>
<li>I focus on the statistical techniques behind the proposed approach, elastic weight consolidation (EWC), which is best described as <em>on-line sequential (diagonalised) Laplace approximation</em></li>
<li>Bayesian inference wouldn't suffer from catastrophic forgetting which haunts optimisation-based methods</li>
<li>EWC approximates Bayesian computation</li>
<li>then I look at what happens moving on to <em>the third task</em>. This detail is somewhat glanced over in the paper.</li>
<li>applying the methodology consistently, I arrive at a formula which is <em>inconsistent with the paper</em> on how the third task is learned.</li>
<li>the paper suggests keeping multiple parameters and penalties around from all previously learnt tasks, but I think <strong>only the latest parameter should be kept</strong> as it already implicitly captures all previous tasks.</li>
<li>keeping multiple quadratic penalties from previous tasks might actually hurt the method's ability to learn new tasks, and results in EWC disproportionately favouring tasks learnt early on</li>
<li>keeping a single quadratic penalty would also eliminate the need to know what task is currently being performed - although a smart solution for this may help agent performance.</li>
</ul>

<h1 id="highleveloverview">High level overview</h1>

<h4 id="takehomemessagebayesiansneverforgetcatastrophically">Take home message: Bayesians never forget (catastrophically)</h4>

<p>There are situations when you want to use the same neural net to solve a range of different tasks. This is not usually a problem if you can afford to train the network on all the tasks simultaneously. The catastrophic forgetting problem arises, however, when you want to train the network to perform new tasks sequentially. How do you train the network on the $k+1$st task without it forgetting everything it knew about the first $k$ tasks?</p>

<p>The authors observe that the <em>catastrophic forgetting</em> does not happen when the network parameters are learnt in a fully Bayesian way. Instead of obtaining single parameter estimate $\theta$ via gradient descent, we really want to maintain a <strong>full Bayesian posterior distribution</strong> $p(\theta\vert \mathcal{D}_{T_1}, \ldots \mathcal{D}_{T_k})$ over possible parameter values that worked well in previous tasks $T_1 \ldots T_k$. Then we could simply use this posterior as a prior when solving the $k+1$st task $T_{k+1}$ and obtain an updated posterior which captures all tasks $T_1 \ldots T_{k+1}$</p>

<p>Of course, maintaining a full posterior is intractable, and even approximating it can be pretty tricky. How do we bridge the gap between the statistical awesomeness of Bayesian inference and the sheer efficiency of gradient descent? The authors opt for a <em>on-line diagonalised Laplace approximation</em> approach, which they call elastic weight consolidation (EWC). The approach is similar to assumed density filtering (ADF, <a href="http://publications.aston.ac.uk/1444/1/NCRG_99_029.pdf">Opper &amp; Winther, 1999</a>), which is a precursor to expectation-propagation (<a href="https://arxiv.org/pdf/1301.2294.pdf">Minka, 2001</a>), a connection highlighted by the authors.</p>

<h4 id="laplaceapproximation">Laplace approximation</h4>

<p>Laplace approximation takes a probability density $p$ and approximates it with a Gaussian, whose mean is at the mode of the distribution and variance is given by the inverse Hessian of the log density $\log p$ at the mode. This approximation to Bayesian posteriors is motivated by Bernstein-von Mises-type convergence theorems which state that in identifiable exchangeable models the posterior will converge to the Laplace. EWC uses a <strong>diagonalised Laplace approximation</strong>, which ignores the off-diagonal entries of the Hessian and keeping only diagonal ones. Applied to neural networks, the diagonal assumption is the same as saying that the parameters of the network have completely independent influence on the loss function (which is of course not true, but perhaps true enough).</p>

<p>The elastic weight consolidation (EWC) method proposed in the PNAS paper essentially applies Laplace approximation recursively, in an on-line fashion, learning one task after another with a neural network.</p>

<h1 id="divingdeeper">Diving deeper</h1>

<p>Let's look at what precisely the EWC algorithm does.</p>

<h4 id="learningasecondtaskafterthefirst">Learning a second task after the first</h4>

<p>This is the easier case. Let's follow the footsteps of the authors, with a slight change in notation. The posterior of NN parameters $\theta$ given the first two tasks $A$ and $B$ can be decomposed as follows:</p>

<p>$$
\log p(\theta\vert \mathcal{D}_A, \mathcal{D}_B) = \log p(\mathcal{D}_B\vert \theta) + \log p(\theta\vert \mathcal{D}_A) - \log p(\mathcal{D}_B\vert \mathcal{D}_A)
$$</p>

<p>The left-hand term is the log likelihood, or task-specific objective function for task $B$, the right-hand term can be thought of as an adaptive elastic weight regularizer that tries to maintain knowledge of the first task. <small>I think there's an irrelevant typo in the paper: the last term of Eqn. (2) should be $\log p(\mathcal{D}_B\vert \mathcal{D}_A)$ rather than $\log p(\mathcal{D}_B)$. It doesn't matter as it's constant w.r.t. $\theta$ anyway.</small></p>

<p>$\log p(\theta\vert \mathcal{D}_A)$, of course, is intractable to compute, so we're going to approximate it with a diagonalised Laplace approximation. For this we need the mode $\operatorname{argmax}_\theta \log p(\theta\vert \mathcal{D}_A)$ and the Hessian of $\log p(\theta\vert \mathcal{D}_A)$ evaluated at the mode.</p>

<p>The mode $\theta^A$ can be found via usual gradient descent, minimising the loss $\mathcal{L}_A(\theta) - \log p(\theta)$, where the prior $p(\theta)$ acts as a regulariser. (the authors don't actually use a prior so ignore that term). The Hessian will be the sum of the Fisher information from task $A$ which I denote $F^A$, plus the Hessian of the log prior $\log p(\theta)$ (which, again, the paper doesn't have. This is no big deal as the prior would probably be a dummy weak regulariser anyway).</p>

<p>So, substituting these back to a diagonalised Laplace approximation we obtain:</p>

<p>$$
\log p(\theta\vert \mathcal{D}_A, \mathcal{D}_B) \approx -\mathcal{L}_B(\theta) - \frac{1}{2}\sum_i F^A_{i,i} (\theta_i - \theta^A_i)^2 + \text{constant}
$$</p>

<p>where $\mathcal{L}_B$ is the negative log likelihood, or loss function, of task $B$, and the Gaussian approximation to $p(\theta\vert \mathcal{D}_A)$ acts as a nice quadratic regulariser, which is dependent on data from task $A$. The authors also introduce $\lambda$, an importance weight which I will assume is $1$ to keep things simple.</p>

<p>We can now train our network via our favourite gradient descent technique solving the following optimisation:</p>

<p>$$
\theta^{A,B} = \operatorname{argmin}_\theta \mathcal{L}_B(\theta) + \frac{1}{2}\sum_i F^A_{i,i} (\theta_i - \theta^A_i)^2
$$</p>

<p>Pretty cool. We have a data-dependent $L_2$ regulariser which adapts to task $A$ we already learnt about. This regulariser captures our knowledge of task $A$, so we can now focus on the new task $B$, while the regulariser makes sure we don't catastrophically forget about $A$. Makes sense.</p>

<p>As a result, $\theta^{A,B}$ will be a parameter that has good performance on both $A$ and $B$.</p>

<h4 id="learningthethirdtaskafterthefirsttwo">Learning the third task after the first two</h4>

<p>On moving to the third task, the authors say only this:</p>

<blockquote>
  <p>When moving to a third task, task C, EWC will try to keep
  the network parameters close to the learned parameters of both tasks A and B. This can be enforced either with two separate penalties or as one by noting that the sum of two quadratic penalties is itself a quadratic penalty</p>
</blockquote>

<h1 id="">ü§î</h1>

<p>Do we actually need to remember $\theta^A$? $\theta^{A,B}$ is supposed to be the mode of the posterior $p(\theta\vert \mathcal{D}_A, \mathcal{D}_B)$ and the posterior already captures all our knowledge about <em>both tasks</em> $A$ and $B$. The mode of the previous posterior $\theta^A$ should become irrelevant as it is already incorporated into $\theta^{A,B}$. Somehow, this just doesn't feel right.</p>

<p>Let's apply the sequential diagonal Laplace approximation argument consistently, but now for learning the third task $C$, after $A$ and $B$. For this, we need the mode and Hessian of the posterior $p(\theta\vert \mathcal{D}_A, \mathcal{D}_B, \mathcal{D}_C)$, which can be expressed as:</p>

<p>$$
\log p(\theta\vert \mathcal{D}_A, \mathcal{D}_B, \mathcal{D}_C) = -\mathcal{L}_C(\theta) + \log p(\theta \vert \mathcal{D}_A, \mathcal{D}_B) + \text{constant}
$$</p>

<p>Let's replace the intractable $\log p(\theta \vert \mathcal{D}_A, \mathcal{D}_B)$ with its Laplace approximation, once again. We have already calculated the mode of this distribution, it is (approximately) $\theta^{A,B}$. How about its Hessian around $\theta^{A,B}$? Well, we have assumed that</p>

<p>$$
\log p(\theta \vert \mathcal{D}_A, \mathcal{D}_B) \approx - \mathcal{L}_B(\theta) - \sum_i F^{A}_{i,i} (\theta_i -\theta^A_i)^2 + \text{constant}
$$</p>

<p>so the Hessian is the Fisher information matrix $F^{B}$ plus the previously assumed diagonal approximation $diag(F^{A})$. So, if we plug these in to form a diagonal Laplace approximation to $\log p(\theta\vert \mathcal{D}_A, \mathcal{D}_B)$, we get:</p>

<p>$$
\log p(\theta\vert \mathcal{D}_A, \mathcal{D}_B) \approx - \sum_i (F^{A} + F^{B})_{i,i} (\theta_i - \theta^{A,B}_i)^2 + \text{constant}
$$</p>

<p>Using this approximation, the optimisation problem for task $C$ after tasks $A$ and $B$ have been learnt will look like:</p>

<p>$$
\theta^{A,B,C} = \operatorname{argmin}_\theta \mathcal{L}_C + \sum_i (F^{A} + F^{B})_{i,i} (\theta_i - \theta^{A,B}_i)^2
$$</p>

<p>Note that there is <strong>just a single penalty</strong>, and it is around $\theta^{A,B}$ which is the parameter we learnt for task $B$ while regularising for not forgetting task $A$. We don't need a second penalty term around $\theta^A$ as it's already been taken into account when finding $\theta^{A,B}$. $\theta^{A}$ is now irrelevant and we can throw it away. $\theta^{A,B}$ (approximately) captures both tasks $A$ and $B$. All we need to do is update the regulariser's weights to $F^{A,B}_{i,i} := (F^{A}_{i,i} + F^{B})_{i,i}$.</p>

<p>So, let's contrast this with what the paper says: "When moving to a third task, task $C$, EWC will try to keep the network parameters close to the learned parameters of both tasks A and B. This can be enforced either with two separate penalties or as one by noting that the sum of two quadratic penalties is itself a quadratic penalty."</p>

<p>I don't think this is the correct approach. There are a few possible explanations, in the order of my preference:</p>

<ul>
<li>I made a mistake here and my derivation is wrong</li>
<li>the authors use a different reasoning from mine to derive multiple, task-specific penalties for the third task, in which case I'd be curious to hear that</li>
<li>the paper described what is actaully done ambiguously in the text, and they actually do the right thing when implementing EWC</li>
<li>the authors made a mistake, and if this is the case the algorithm may be further improved by fixing the mistake</li>
</ul>

<h4 id="whywouldmultiplepenaltiesbewrong">Why would multiple penalties be wrong?</h4>

<p>Let's see what happens if you do keep the two penalties around, one centered around $\theta^A$ and one around $\theta^{A,B}$? In a handwavy way, it corresponds to optimising something a bit - but not quite - like this:</p>

<p>$$
-\mathcal{L}_{C} + \log p(\theta\vert \mathcal{D}_A, \mathcal{D}_B) + \log p(\theta\vert \mathcal{D}_A)
$$</p>

<p>Not only does this formula not add up from Bayes' rule's perspective, it also places too much emphasis on task $A$, more than what Bayes' rule would warrant. Furthermore, as more tasks are added, task A will be overemphasized further. Therefore, I think</p>

<blockquote>
  <p>keeping multiple penalties around might result in a diminished ability to learn new tasks, as early tasks get disproportionately more weight.</p>
</blockquote>

<p>In a thought experiment, imagine what would happen if $\mathcal{L}_{C}$ were completely flat, that is, you want to learn task $C$, but you have no actual data, or the data provides no information about $\theta$ (I know, stupid assumption, but makes sense to think about it). Let's run gradient descent on the penalised loss nevertheless, essentially minimising only penalty term(s).</p>

<p>If you have the one penalty around the most recently learned parameter $\theta^{A,B}$, as in my derivation, then $\theta^{A,B}$ is already the minimum. If task $C$ has no new data, you just don't change your parameters from what you had before. Makes sense, right? If it's not broken, why fix it?</p>

<p>However, if you have the two penalties, one around $\theta^{A,B}$, and one around $\theta^A$, your optimisation will actually move away from $\theta^{A,B}$, back towards $\theta^A$ a bit. But this would make no sense at all. Why would you change the parameters if you are presented with no new evidence at all?</p>

<p>For the South Park afficionados out there: the extra penalties are basically member berries. They will make your network want to go back to the old ways when it solved task $A$ perfectly and everything seemed so easy.</p>

<p><img src="/content/images/2017/03/1ljk1i-1.jpg" alt="" /></p>

<h4 id="doesitactuallyappeartohurtthealgorithm">Does it actually appear to hurt the algorithm?</h4>

<p>Well, not really. At least it's hard to tell from the Figures. Look at Figure 3.A:</p>

<p><img src="/content/images/2017/03/Screen-Shot-2017-03-16-at-12.17.00-PM.png" alt="" /></p>

<p>This shows that while EWC very successfully retains its performance at task $A$, the gap between SGD and EWC on new tasks widen. How would the harmful effects of keeping two penalties around show up on this Figure?</p>

<ol>
<li>Performance on Task $A$ first goes down a bit after training for a few new tasks, but then eventually gradually goes up again as we train for tasks $E,F\ldots$. This would happen because as time goes by, you implicitly add the 'Task A' penalty over and over again, even though that penalty is implicitly captured in all other task penalties as well. We can't really see this effect here, partly because the performance on task A never really drops, and partly because it only shows 3 tasks. Plus, a lot of this depends on how the $\lambda$ values were chosen, too.  </li>
<li>The gap between EWC and SGD for Task B would be much smaller than the gap between EWC and SGD for Task C. Again, it's hard to say if this is the case or not from this figure.</li>
</ol>

<p>Similarly, looking at Figure 3.B doesn't really help us analyse if the mismatch in penalties causes any problems, because we only see average task performance.</p>

<h4 id="doyouevenneedtoknowwhattaskyoureperforming">Do you even need to know what task you're performing?</h4>

<p>This is what the authors write about the need to identify the task being performed:</p>

<blockquote>
  <p>Inspired by this evidence, we augmented the DQN agents with
  extra functionality to handle switching task contexts. Knowledge of which task is being performed is required for the EWC algorithm as it informs which quadratic constraints are currently active and also which quadratic constraint to update when the task context changes.</p>
</blockquote>

<p>Now, good news is that knowledge of task identity may not be a requirement for the algorithm to work after all. If there are no task-specific quadratic penalties, only a single one, we don't have to choose betwen them. We can just update the single posterior mode $\theta^{A,\ldots}$ and the Hessian $F^{A,\ldots}$ in an on-line fashion and forget their old values.</p>

<p><small><font color="#aa7744"><em>sidenote</em>: In fact, EWC with a single quadratic penalty could be applied more generally than the catastrophic forgetting problem. There is nothing in the derivation that specifies that $\mathcal{D}_A$ and $\mathcal{D}_B$ should in fact correspond to two different tasks. They can even contain data from different tasks, so we don't even need to synchronise the freezing of the quadratic penalty with swittching tasks.</p>

<p>Or, $\mathcal{D}_A,\mathcal{D}_B,\ldots$ can be minibatches of data from a single task, in which case EWC can be thought of as an on-line alternative to stochastic gradient descent. Consider looping through the minibatches one-by-one. On each minibatch, instead of doing a single gradient step like in SGD, we run full gradient descent with a quadratic regulariser until convergence.  Once converged, we update the quadratic regulariser according to the Laplace rules, and load the next minibatch. This may not be as accurate as SGD because of the diagonal Laplace approximation introduces inaccuracies over time. But it would require less overall data shoveling between GPU memory and main memory, and it accesses each minibatch exactly once. So there might be situations when such algorithm would be a meaningful alternative to SGD.</font></small></p>

<p>Of course, the agent performing the tasks will probably still benefit from an elaborate mechanism to detect task identity, but that is a different concern entirely. The point is, the algorithm at a computational level is agnostic to tasks beyond evaluating the loss functions $\mathcal{L}_A,\mathcal{L}_B,\ldots$</p>

<h2 id="summary">Summary</h2>

<p>This is a great paper, and a great demonstration of how a simple, statistically motivated algorithm can make a huge difference.</p>

<p>I did, honestly, set out to write a very positive review, I really liked the statistical motivation, and the resulting simplicity of the method. The experiments are also interesting and well done, the results speak for themselves. It is also exciting to think about how this can be used in practice, and being able to learn tasks sequentially is bound to have a massive impact.</p>

<p>But look at the post now: at best, I'd describe it as constructive criticism, I ended up zooming in on the one thing that wasn't quite kosher, even though you can hardly argue with the performance of the method. But this is also a good motivation for continuing to write these posts: had I not started trying to explain how and why the method works, I may have missed this entirely. And then, of course, it is entirely possible that the authors actually did the same thing I describe here, just explained it in a different way, or that there are alternative justifications for the multiple penalties approach.</p>
</article>

<div id="comments">
    <div id="disqus_thread"></div>
    <script>
        var disqus_config = function () {
            this.page.url = 'http://www.inference.vc/comment-on-overcoming-catastrophic-forgetting-in-nns-are-multiple-penalties-needed-2/';
            this.page.identifier = 103;
            };
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document, s = d.createElement('script'); s.src = '//inference.disqus.com/embed.js'; s.setAttribute('data-timestamp', +new Date()); (d.head || d.body).appendChild(s); })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</div>

		</main>
		<footer id="footer">
			<section id="footer-message">&copy; 2017 inFERENCe. All rights reserved. Powered by <a href="http://ghost.org" target="_blank">Ghost</a>. <a href="http://github.com/kathyqian/crisp" target="_blank">Crisp</a> theme by <a href="http://kathyqian.com" target="_blank">Kathy Qian</a>.</section>
		</footer>
	<!-- You can safely delete this line if your theme does not require jQuery -->
<script type="text/javascript" src="https://code.jquery.com/jquery-1.11.3.min.js"></script>
		<script type="text/javascript"     src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

		<script type="text/x-mathjax-config">
		MathJax.Hub.Config({
		    tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
		});
		</script>
	</body>

</html>
